---
title: grpcurl ã‚’ã‚³ãƒ¼ãƒ‰ãƒªãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
tags:
  - Go
  - gRPC
  - grpcurl
private: false
updated_at: '2022-12-23T08:43:43+09:00'
id: a033a64df9cd468ae799
organization_url_name: null
slide: false
---
ã“ã‚“ã«ã¡ã¯ã€ã—ã‚…ã‚“ï¼ˆ[@MxShun](https://twitter.com/MxShun)ï¼‰ã§ã™ã€‚
ä»Šå¹´11æœˆã«ã‚µã‚¤ãƒãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«ä¸­é€”å…¥ç¤¾ã€AIäº‹æ¥­æœ¬éƒ¨ã‚ªãƒšãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼ã«ä»²é–“å…¥ã‚Šã—ã¾ã—ãŸã€‚

<å®£ä¼>

ğŸ‘‰ åŒã˜ãæœ¬æ—¥æŠ•ç¨¿ã®ã€CyberAgent Advent Calendar 2022ã€Œ[ç§ãŒã‚„ã£ãŸ Amazon S3 ã‚³ã‚¹ãƒˆã‚«ãƒƒãƒˆå…¨ã‚¹ãƒ†ãƒƒãƒ—](https://developers.cyberagent.co.jp/blog/archives/38950/)ã€ã‚ˆã‘ã‚Œã°ã”è¦§ãã ã•ã„ï¼
ğŸ‘‰ ç¤¾å†…ã®æ–¹ã¯ã€*#times_mxshun* ã‚ˆã‘ã‚Œã°è¦—ã„ã¦ã‚ã’ã¦ãã ã•ã„ï¼

\</å®£ä¼>

# grpcurl
gRPC ç•Œéšˆã§ã¯è¨€ã‚ãšã¨çŸ¥ã‚ŒãŸã€gRPC ã‚µãƒ¼ãƒã«å¯¾ã—ã¦ cURL ã§ãã‚‹ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ãƒ„ãƒ¼ãƒ«ã§ã™ã€‚

> grpcurl is a command-line tool that lets you interact with gRPC servers. It's basically curl for gRPC servers.

https://github.com/fullstorydev/grpcurl

# ã‚³ãƒ¼ãƒ‰ãƒªãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ [v1.8.7](https://github.com/fullstorydev/grpcurl/releases/tag/v1.8.7) ã§ã™ã€‚

### `main.grpcurl`
å‡¦ç†ã®å†’é ­ã¯ã€ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ãƒ„ãƒ¼ãƒ«ã®æ‰€è¬‚ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†ã§ã™ã€‚èª­ã¿é£›ã°ã—ã¾ã™ã€‚

æœ€åˆã«ç€ç›®ã™ã¹ãã¯ã€`grpcurl.BlockingDial` ã‚’[å‘¼ã³å‡ºã—ã¦ã„ã‚‹ç®‡æ‰€](https://github.com/fullstorydev/grpcurl/blob/25c896aa59ffc36f7d12cf5d6c18e9c8f4421bfa/cmd/grpcurl/grpcurl.go#L460)ã§ã™ã€‚ã¤ã¾ã‚Šã€ã“ã“ã§ gRPC ã‚µãƒ¼ãƒã¨ã®ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ç¢ºç«‹ã—ã¦ã„ã¾ã™ã€‚

```go
cc, err := grpcurl.BlockingDial(ctx, network, target, creds, opts...)
```

```grpcurl/grpcurl.go
// BlockingDial is a helper method to dial the given address, using optional TLS credentials,
// and blocking until the returned connection is ready. If the given credentials are nil, the
// connection will be insecure (plain-text).
func BlockingDial(ctx context.Context, network, address string, creds credentials.TransportCredentials, opts ...grpc.DialOption) (*grpc.ClientConn, error)
```

å°‘ã—æˆ»ã£ã¦ `ctx` ã‚’è¿½ã†ã¨ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã ã‘ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«[è©°ã‚ã¦ã„ã¾ã—ãŸ](https://github.com/fullstorydev/grpcurl/blob/25c896aa59ffc36f7d12cf5d6c18e9c8f4421bfa/cmd/grpcurl/grpcurl.go#L387)ã€‚

```go
ctx := context.Background()
// ä¸­ç•¥
ctx, cancel = context.WithTimeout(ctx, timeout)
```

https://go.dev/blog/context

DescriptorSource ã¯ã€ProtoSets ã‚‚ã—ãã¯ ProtoFilesã€ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«å¯¾å¿œã—ã¦ã„ã‚‹ã®ã§ã‚ã‚Œã° gRPC ã‚µãƒ¼ãƒã‹ã‚‰ã®æƒ…å ±ã‚’ã‚‚ã¨ã«ç”Ÿæˆã—ã¾ã™ã€‚

```go
if len(protoset) > 0 {
    // ä¸­ç•¥
    fileSource, err = grpcurl.DescriptorSourceFromProtoSets(protoset...)
    // ä¸­ç•¥
} else if len(protoFiles) > 0 {
    // ä¸­ç•¥
    fileSource, err = grpcurl.DescriptorSourceFromProtoFiles(importPaths, protoFiles...)
    // ä¸­ç•¥
}
if reflection.val {
    md := grpcurl.MetadataFromHeaders(append(addlHeaders, reflHeaders...))
    refCtx := metadata.NewOutgoingContext(ctx, md)
    cc = dial()
    refClient = grpcreflect.NewClient(refCtx, reflectpb.NewServerReflectionClient(cc))
    reflSource := grpcurl.DescriptorSourceFromServer(ctx, refClient)
    if fileSource != nil {
        descSource = compositeSource{reflSource, fileSource}
    } else {
        descSource = reflSource
    }
} else {
    descSource = fileSource
}
```

ãã—ã¦ã€`grpcurl.InvokeRPC` ã§[å®Ÿéš›ã« RPC ã—ã¦ã„ã¾ã™](https://github.com/fullstorydev/grpcurl/blob/25c896aa59ffc36f7d12cf5d6c18e9c8f4421bfa/cmd/grpcurl/grpcurl.go#L707)ã€‚
`cc` ã«ã¯ DescriptorSource ã§ã“ãã£ã¨ `dial()` ã‚’ä»£å…¥ã—ã¦ãŠã‚Šã€`ch` ã¨ã—ã¦ç¢ºç«‹ã•ã‚ŒãŸãƒãƒ£ãƒãƒ«ãŒæ¸¡ã•ã‚Œã¦ã„ã¾ã™ã€‚

```go
err = grpcurl.InvokeRPC(ctx, descSource, cc, symbol, append(addlHeaders, rpcHeaders...), h, rf.Next)
```

```grpcurl/invoke.go
// InvokeRPC uses the given gRPC channel to invoke the given method. The given descriptor source
// is used to determine the type of method and the type of request and response message. The given
// headers are sent as request metadata. Methods on the given event handler are called as the
// invocation proceeds.
//
// The given requestData function supplies the actual data to send. It should return io.EOF when
// there is no more request data. If the method being invoked is a unary or server-streaming RPC
// (e.g. exactly one request message) and there is no request data (e.g. the first invocation of
// the function returns io.EOF), then an empty request message is sent.
//
// If the requestData function and the given event handler coordinate or share any state, they should
// be thread-safe. This is because the requestData function may be called from a different goroutine
// than the one invoking event callbacks. (This only happens for bi-directional streaming RPCs, where
// one goroutine sends request messages and another consumes the response messages).
func InvokeRPC(ctx context.Context, source DescriptorSource, ch grpcdynamic.Channel, methodName string,
	headers []string, handler InvocationEventHandler, requestData RequestSupplier)
```

`grpcurl.InvokeRPC` ã«ç›´æ¥çš„ãªæˆ»ã‚Šå€¤ã¯ãªã„ã§ã™ãŒã€EventHandler ã‚’é€šã˜ã¦ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚„ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ãŒè¿”å´ã•ã‚Œã‚‹ã‚ˆã†ã§ã™ã€‚ãã—ã¦ã€EventHandler ã«ä¹—ã£ã‹ã£ã¦ããŸå€¤ã‚’ã‚‚ã¨ã«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«çµæœã‚’è¿”å´ã—ã¦ã„ã¾ã™ã€‚

æ„å¤–ã¨ã‚·ãƒ³ãƒ—ãƒ«ãªä½œã‚Šã§ã—ãŸã€‚

### `grpcurl.grpcurl`
`main.grpcurl` ã¯ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ãƒ„ãƒ¼ãƒ«æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ãŒã€`grpcurl.grpcurl` ã¯ grpcurl ã®ã‚³ã‚¢æ©Ÿèƒ½ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚

```go
// Package grpcurl provides the core functionality exposed by the grpcurl command, for
// dynamically connecting to a server, using the reflection service to inspect the server,
// and invoking RPCs. The grpcurl command-line tool constructs a DescriptorSource, based
// on the command-line parameters, and supplies an InvocationEventHandler to supply request
// data (which can come from command-line args or the process's stdin) and to log the
// events (to the process's stdout).
```

API ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆçš„ã«ä¸€éƒ¨ã‚’æŠœç²‹ã—ã¦ã¾ã¨ã‚ã¦ã¿ã¾ã™ã€‚

| æˆ»ã‚Šå€¤å‹ | ãƒ¡ã‚½ãƒƒãƒ‰ | èª¬æ˜ |
| --- | --- | --- |
| `[]string, error` | `ListServices(source DescriptorSource)` | DescriptorSource ã‚’ã‚‚ã¨ã« gRPC ã‚µãƒ¼ãƒ“ã‚¹ä¸€è¦§ã‚’å–å¾—ã—ã¾ã™ã€‚ |
| `[]*desc.FileDescriptor, error` | `GetAllFiles(source DescriptorSource)` | DescriptorSource ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã® descriptor ä¸€è¦§ã‚’å–å¾—ã—ã¾ã™ã€‚ |
| `int` | `(f filesByName) Len()` | `[]*desc.FileDescriptor` ã«å¯¾ã—ã¦ `sort.Interface` ã‚’æº€ãŸã™ãŸã‚ã® `Len` ã‚’æä¾›ã—ã¾ã™ã€‚ |
| `bool` | `(f filesByName) Less(i, j int)` |  `[]*desc.FileDescriptor` ã«å¯¾ã—ã¦ `sort.Interface` ã‚’æº€ãŸã™ãŸã‚ã® `Less` ã‚’æä¾›ã—ã¾ã™ã€‚ |
| - | `(f filesByName) Swap(i, j int)` |  `[]*desc.FileDescriptor` ã«å¯¾ã—ã¦ `sort.Interface` ã‚’æº€ãŸã™ãŸã‚ã® `Swap` ã‚’æä¾›ã—ã¾ã™ã€‚ |
| `[]string, error`| `ListMethods(source DescriptorSource, serviceName string)` | DescriptorSource ã¨ã‚µãƒ¼ãƒ“ã‚¹åã‚’ã‚‚ã¨ã«æä¾›ã•ã‚Œã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ä¸€è¦§ã‚’å–å¾—ã—ã¾ã™ã€‚ |
| `metadata.MD` | `MetadataFromHeaders(headers []string)` | `"Header-Name: Header-Value"` ã¨ã„ã†ã‚­ãƒ¼ãƒãƒªãƒ¥ãƒ¼å½¢å¼ã®ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã«å¤‰æ›ã—ã¾ã™ã€‚ |
| `[]string, error` | `ExpandHeaders(headers []string)` | ãƒ˜ãƒƒãƒ€ãƒ¼ã«å«ã¾ã‚Œã‚‹ç’°å¢ƒå¤‰æ•°ã‚’å±•é–‹ã—ã¾ã™ã€‚ |
| `string` | `MetadataToString(md metadata.MD)` | ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æ¨™æº–å‡ºåŠ›ç”¨ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚ |
| `string, error` | `GetDescriptorText(dsc desc.Descriptor, _ DescriptorSource)` | Descriptor ãŒæä¾›ã™ã‚‹ã‚‚ã®ã‚’ã‚¹ãƒ‹ãƒšãƒƒãƒˆã¨ã—ã¦ãƒ†ã‚­ã‚¹ãƒˆå½¢å¼ã§å–å¾—ã—ã¾ã™ã€‚ |
| `proto.Message` | `EnsureExtensions(source DescriptorSource, msg proto.Message)` | æ¸¡ã—ãŸ `proto.Message` ã«å¯¾ã— DescriptorSource ãŒæä¾›ã™ã‚‹ gRPC ã‚µãƒ¼ãƒæ‹¡å¼µæ©Ÿèƒ½ã‚’åŠ å‘³ã—ãŸå‹•çš„ãƒ¡ãƒƒã‚»â€•ã‚¸ã¨ã—ã¦å–å¾—ã™ã‚‹ã€‚ |
| `error` | `fetchAllExtensions(source DescriptorSource, ext *dynamic.ExtensionRegistry, md *desc.MessageDescriptor, alreadyFetched map[string]bool)`| gRPC ã‚µãƒ¼ãƒæ‹¡å¼µæ©Ÿèƒ½ä¸€è¦§ã‚’ `ext`ã€€ã«å–å¾—ã—ã¾ã™ã€‚ |
| `proto.Message` | `MakeTemplate(md *desc.MessageDescriptor)` | `MessageDescriptor` ã«é©ã—ãŸ JSON å½¢å¼ã® `proto.Message` ã‚’è¿”å´ã—ã¾ã™ã€‚ |
| `credentials.TransportCredentials, error` | `ClientTransportCredentials(insecureSkipVerify bool, cacertFile, clientCertFile, clientKeyFile string)` | ä¸ãˆã‚‰ã‚ŒãŸãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ã‚‚ã¨ã« TLS è¨­å®šã‚’æ§‹ç¯‰ã—ã€gRPC ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®`TransportCredentials` ã‚’ç”Ÿæˆãƒ»è¿”å´ã™ã‚‹ã€‚ |
| `*tls.Config, error` | `ClientTLSConfig(insecureSkipVerify bool, cacertFile, clientCertFile, clientKeyFile string)` | gRPC ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã® TLS è¨­å®šã‚’ç”Ÿæˆã™ã‚‹ã€‚ |
| `credentials.TransportCredentials, error`| ` ServerTransportCredentials(cacertFile, serverCertFile, serverKeyFile string, requireClientCerts bool)` | ä¸ãˆã‚‰ã‚ŒãŸãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ã‚‚ã¨ã« TLS è¨­å®šã‚’æ§‹ç¯‰ã—ã€gRPC ã‚µãƒ¼ãƒã®`TransportCredentials` ã‚’ç”Ÿæˆãƒ»è¿”å´ã™ã‚‹ã€‚ |
| `*grpc.ClientConn, error` | `BlockingDial(ctx context.Context, network, address string, creds credentials.TransportCredentials, opts ...grpc.DialOption)` | TLS Credentials ã‚’ã‚‚ã¨ã«ç¢ºç‡ã—ãŸã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿”å´ã™ã‚‹ã€‚ |

# æ‰€æ„Ÿ
gRPC ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’çŸ¥ã‚‹ã“ã¨ã§ã€gRPC ãã®ã‚‚ã®ã®ä»•çµ„ã¿ã‚‚å†ç¢ºèªã§ãã¾ã—ãŸã€‚

ã¾ãŸèˆˆå‘³æœ¬ä½ã§ã‚³ãƒ¼ãƒ‰ãƒªãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã™ã‚‹æ©Ÿä¼šãŒã‚ã‚Œã°è¨˜äº‹ã«ã—ãŸã„ã¨æ€ã„ã¾ã™ã€‚ãã‚Œã§ã¯ã‚ˆã„ã‚¯ãƒªã‚¹ãƒã‚¹ã‚’ï¼
